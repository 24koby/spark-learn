闭包是一个函数，一种比较特殊的函数。为了解释闭包这个概念，
我们在Linux系统的“/usr/local/scala/mycode”目录下新建test.scala代码文件，里面包含以下内容：
object MyTest{
    def main(args: Array[String]): Unit={    
        def plusStep(step: Int) = (num: Int) => num + step
        //给step赋值
        val myFunc = plusStep(3)
        //调用myFunc函数
        println(myFunc(10))     
    }
}
在上面的MyTest中， step是一个自由变量，它的值只有在运行的时候才能确定，
num的类型是确定的，num的值只有在调用的时候才被赋值。这样的函数，被称为“闭包”，它反映了一个从开放到封闭的过程。

函数中传递变长参数
def max(values: Int*)=values.foldLeft(values(0)){Math.max}  限定类型
def max(values: _*)=values.foldLeft(values(0)){Math.max} 不限定类型

参数默认值
def fuc(arg1:String = "das",arg2: Int = 5): Unit =println(s"send $arg and $arg2")
采用默认值后可以省略参数调用
但是默认值是按变量的位置顺序赋值，就是必须要从第一个参数使用默认值后面的默认值才能使用:解决方法如下：命名参数传值
可以指定方法中参数名例如 fuc(arg2="sa"),但是对于没有默认值的参数必须给定值，有默认值的可以选择使用命名参数传值，一个参数只能传一个值

隐式参数
需要在变量前声明implict

闭包，是函数的特殊形式，会捕获或者绑定在另一个作用域或上下文中定义的变量


可扩展性和高阶函数
可以将其他函数作为参数的函数成为高阶函数，它能减少代码重复，提高代码复用性，简化代码
def totalResultOverRange(number: Int, codeBlock:Int=> Int)={
	var result = 0
	for(i<- 1 to number){
		result += codeBlock(i)
	}
	result
}

柯里化
它会把接收多个参数的函数转化为接收多个参数列表的函数
它是将函数中的多个参数转化为多个参数列表
def inject(arr: Array[Int], initial: Int)(operation:(Int,Int)=>Int):Int={
	var carryOver = initial
	arr.foreach(element => carryOver = operation(carryOver,element))
	carryOver
}
var sum: Int = inject(array, 0) {(carryOver.elem)=> carryOver + elem}

参数占位符_




