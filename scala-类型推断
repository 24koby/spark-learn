针对结合的类型推断
var list1 = new util.ArrayList[Int]
var list2 = new util.ArrayList  //会生成ArrayList[Nothing]类型
list1 == list2//编译错误

基础类型
Any是所有类型的基类
Nothing是所有类型的子类

Option类型包括Some和None,推荐集合中尽量返回空值而不要返回null

Either类型包括左值(Left,一般指错误)和右值(Right，一般指正确类型的值)

在定义函数时，scala也可以对函数返回值进行类型推断

参数化类型的型变
协变：在期望接收一个基类实例的集合的地方，能够使用一个子类实例的集合的能力叫做协变
逆变：在期望接收一个子类实例的集合的地方，能够使用一个超类实例的集合的能力叫做逆变

参数化类型的型变
支持协变

def playWithPets[T<:Pet](pets:Array[T]):Unit={}

T<:Pet表明由T表示的类派生自Pet类，这个语法定义了一个上界，通过制定上界告诉scala数组参数的类型T必须至少是一个Pet的数组(这里使用侧协变而不是定义侧协变)

支持逆变
def copyPets[S,D>:S](fromPets:Array[S],toPets:Array[D}):Unit={}
我们限定了目标数组的参数化类型D，将其限定为原数组的参数化类型S的一个超类型。换句话说，S设定了D的下界，它可以是类型S，也可以是它的超类型

定制集合的型变
class MyList[+T]
var list1 = new MyList[Int]
var list2:MyList[Any]
list2 = list1//编译正确

+T告诉scala允许协变，换句话说，就是在类型检查期间它要求scala接受一个类型或者该类型的派生类。

-T支持逆变


